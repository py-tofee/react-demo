import { useRef, useEffect } from 'react';
import { getGraphSize, processMinimap } from '../graph/util';
import { isObject, isString } from '@antv/util';
export default function useInit(graphInstance, config, container) {
  var graphHook = useRef();
  var data = config.data,
      nodeStyle = config.nodeStyle,
      nodeAnchorPoints = config.nodeAnchorPoints,
      nodeType = config.nodeType,
      edgeType = config.edgeType,
      edgeStyle = config.edgeStyle,
      width = config.width,
      height = config.height,
      layout = config.layout,
      minimapCfg = config.minimapCfg,
      behaviors = config.behaviors,
      nodeLabelCfg = config.nodeLabelCfg,
      edgeLabelCfg = config.edgeLabelCfg;
  var minimap;
  useEffect(function () {
    if (graphInstance && !graphInstance.destroyed) {
      graphInstance.changeData(data);
      graphInstance.layout();
    }
  }, [data]);
  useEffect(function () {
    if (graphInstance && !graphInstance.destroyed) {
      graphInstance.getNodes().forEach(function (node) {
        graphInstance.updateItem(node, {
          type: nodeType,
          style: nodeStyle,
          anchorPoints: nodeAnchorPoints,
          labelCfg: nodeLabelCfg
        });
      });
    }
  }, [nodeStyle, nodeAnchorPoints, nodeType]);
  useEffect(function () {
    if (graphInstance && !graphInstance.destroyed) {
      graphInstance.getEdges().forEach(function (edge) {
        graphInstance.updateItem(edge, {
          type: edgeType,
          style: edgeStyle,
          labelCfg: edgeLabelCfg
        });
      });
    }
  }, [edgeStyle, edgeType]);
  useEffect(function () {
    if (graphInstance && !graphInstance.destroyed) {
      var graphSize = getGraphSize(width, height, container);
      graphInstance.changeSize(graphSize[0], graphSize[1]);
    }
  }, [container, width, height]);
  useEffect(function () {
    if (graphInstance && !graphInstance.destroyed) {
      graphInstance.updateLayout(layout);
    }
  }, [layout]);
  useEffect(function () {
    if (!minimapCfg || !graphInstance || graphInstance.destroyed) {
      return;
    }

    if (minimapCfg.show) {
      minimap = processMinimap(minimapCfg, graphInstance);
      minimap && minimap.updateCanvas();
    } else {
      var _minimap = graphInstance.get('plugins')[0];
      _minimap && graphInstance.removePlugin(_minimap);
    }
  }, [minimapCfg]);
  useEffect(function () {
    if (graphInstance && !graphInstance.destroyed) {
      var _graphInstance$get = graphInstance.get('modes'),
          defaultMode = _graphInstance$get.default;

      var removingBehaviors = [];
      defaultMode.forEach(function (be) {
        if (isObject(be)) {
          removingBehaviors.push(be.type);
        } else if (isString(be)) {
          removingBehaviors.push(be);
        }
      });
      graphInstance.removeBehaviors(removingBehaviors, 'default');
      graphInstance.addBehaviors(behaviors, 'default');
    }
  }, [behaviors]);
  useEffect(function () {
    graphHook.current = graphInstance;

    if (graphInstance && !graphInstance.destroyed) {
      return function () {
        graphInstance.destroy();
        graphInstance = undefined;
      };
    }

    return;
  }, []);
  return {
    graphHook: graphHook
  };
}