import React, { useEffect } from 'react';
import G6 from '@antv/g6/es';
import { ErrorBoundary } from '../base';
import './customItems';
import { processMinimap, getGraphSize } from './util';
import useGraph from '../hooks/useGraph';
var defaultStateStyles = {
  hover: {
    stroke: '#1890ff',
    lineWidth: 2
  }
};
var defaultNodeSize = [120, 40];
var defaultNodeStyle = {
  stroke: '#40a9ff'
};
var defaultNodeAnchorPoints = [[0, 0.5], [1, 0.5]];
var defaultEdgeStyle = {
  stroke: '#ccc',
  endArrow: {
    path: G6.Arrow.vee(10, 10),
    fill: '#ccc'
  }
};
var defaultLayout = {
  type: 'indented',
  direction: 'LR',
  dropCap: false,
  indent: 250,
  getHeight: function getHeight() {
    return 60;
  },
  getWidth: function getWidth(d) {
    return 100;
  }
};
var defaultLabelCfg = {
  style: {
    fill: '#000',
    fontSize: 12
  }
};
var graph;

var IndentedTree = function IndentedTree(_ref) {
  var data = _ref.data,
      className = _ref.className,
      style = _ref.style,
      width = _ref.width,
      height = _ref.height,
      _ref$nodeType = _ref.nodeType,
      nodeType = _ref$nodeType === void 0 ? 'card-node' : _ref$nodeType,
      _ref$edgeType = _ref.edgeType,
      edgeType = _ref$edgeType === void 0 ? 'cubic-horizontal' : _ref$edgeType,
      _ref$behaviors = _ref.behaviors,
      behaviors = _ref$behaviors === void 0 ? ['zoom-canvas', 'drag-canvas'] : _ref$behaviors,
      _ref$nodeSize = _ref.nodeSize,
      nodeSize = _ref$nodeSize === void 0 ? defaultNodeSize : _ref$nodeSize,
      _ref$nodeLabelCfg = _ref.nodeLabelCfg,
      nodeLabelCfg = _ref$nodeLabelCfg === void 0 ? defaultLabelCfg : _ref$nodeLabelCfg,
      _ref$nodeAnchorPoints = _ref.nodeAnchorPoints,
      nodeAnchorPoints = _ref$nodeAnchorPoints === void 0 ? defaultNodeAnchorPoints : _ref$nodeAnchorPoints,
      _ref$layout = _ref.layout,
      layout = _ref$layout === void 0 ? defaultLayout : _ref$layout,
      minimapCfg = _ref.minimapCfg,
      _ref$nodeStyle = _ref.nodeStyle,
      nodeStyle = _ref$nodeStyle === void 0 ? defaultNodeStyle : _ref$nodeStyle,
      _ref$edgeStyle = _ref.edgeStyle,
      edgeStyle = _ref$edgeStyle === void 0 ? defaultEdgeStyle : _ref$edgeStyle,
      _ref$nodeStateStyles = _ref.nodeStateStyles,
      nodeStateStyles = _ref$nodeStateStyles === void 0 ? defaultStateStyles : _ref$nodeStateStyles,
      _ref$edgeStateStyles = _ref.edgeStateStyles,
      edgeStateStyles = _ref$edgeStateStyles === void 0 ? defaultStateStyles : _ref$edgeStateStyles,
      _ref$collapseExpand = _ref.collapseExpand,
      collapseExpand = _ref$collapseExpand === void 0 ? true : _ref$collapseExpand,
      handleEdgeClick = _ref.handleEdgeClick,
      handleEdgeHover = _ref.handleEdgeHover,
      handleEdgeUnHover = _ref.handleEdgeUnHover,
      handleNodeClick = _ref.handleNodeClick,
      handleNodeHover = _ref.handleNodeHover,
      handleNodeUnHover = _ref.handleNodeUnHover,
      handleCanvasClick = _ref.handleCanvasClick,
      graphRef = _ref.graphRef;
  var container = React.useRef(null);
  var props = {
    data: data,
    className: className,
    style: style,
    width: width,
    height: height,
    nodeType: nodeType,
    edgeType: edgeType,
    behaviors: behaviors,
    nodeSize: nodeSize,
    nodeLabelCfg: nodeLabelCfg,
    nodeAnchorPoints: nodeAnchorPoints,
    layout: layout,
    minimapCfg: minimapCfg,
    nodeStyle: nodeStyle,
    edgeStyle: edgeStyle,
    nodeStateStyles: nodeStateStyles,
    edgeStateStyles: edgeStateStyles,
    collapseExpand: collapseExpand,
    handleEdgeClick: handleEdgeClick,
    handleEdgeHover: handleEdgeHover,
    handleEdgeUnHover: handleEdgeUnHover,
    handleNodeClick: handleNodeClick,
    handleNodeHover: handleNodeHover,
    handleNodeUnHover: handleNodeUnHover,
    handleCanvasClick: handleCanvasClick,
    graphRef: graphRef
  };
  useGraph(graph, props, container);
  useEffect(function () {
    var graphSize = getGraphSize(width, height, container);

    if (!graph || graph.destroyed) {
      graph = new G6.TreeGraph({
        container: container.current,
        width: graphSize[0],
        height: graphSize[1],
        modes: {
          default: behaviors
        },
        defaultNode: {
          type: nodeType,
          size: nodeSize,
          style: nodeStyle,
          anchorPoints: nodeAnchorPoints,
          labelCfg: nodeLabelCfg
        },
        defaultEdge: {
          type: edgeType,
          style: edgeStyle
        },
        nodeStateStyles: nodeStateStyles,
        edgeStateStyles: edgeStateStyles,
        layout: layout
      });

      if (graphRef) {
        graphRef.current = graph;
      }
    }

    processMinimap(minimapCfg, graph);
    graph.data(data);
    graph.render();
    graph.fitView();

    if (collapseExpand) {
      graph.on('node:click', function (e) {
        var item = e.item;

        if (e.target.get('name') === 'collapse-icon') {
          graph.updateItem(item, {
            collapsed: !item.getModel().collapsed
          });
          graph.layout();
        } else {
          if (handleNodeClick) {
            handleNodeClick(item, graph);
          }
        }
      });
    }

    graph.on('edge:mouseenter', function (evt) {
      var item = evt.item;
      graph.setItemState(item, 'hover', true);

      if (handleEdgeHover) {
        handleEdgeHover(item, graph);
      }
    });
    graph.on('edge:mouseleave', function (evt) {
      var item = evt.item;
      graph.setItemState(item, 'hover', false);

      if (handleEdgeUnHover) {
        handleEdgeUnHover(item, graph);
      }
    });
    graph.on('edge:click', function (evt) {
      var item = evt.item;

      if (handleEdgeClick) {
        handleEdgeClick(item, graph);
      }
    });
    graph.on('node:mouseenter', function (evt) {
      var item = evt.item;
      graph.setItemState(item, 'hover', false);

      if (handleNodeHover) {
        handleNodeHover(item, graph);
      }
    });
    graph.on('node:mouseleave', function (evt) {
      var item = evt.item;
      graph.setItemState(item, 'hover', false);

      if (handleNodeUnHover) {
        handleNodeUnHover(item, graph);
      }
    });
    graph.on('canvas:click', function (evt) {
      handleCanvasClick && handleCanvasClick(graph);
    });
    return function () {
      return graph.destroy();
    };
  }, []);
  return React.createElement(ErrorBoundary, null, React.createElement("div", {
    className: className,
    style: style,
    ref: container
  }));
};

export default IndentedTree;