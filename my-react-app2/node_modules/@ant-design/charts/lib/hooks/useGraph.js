"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useInit;

var _react = require("react");

var _util = require("../graph/util");

var _util2 = require("@antv/util");

function useInit(graphInstance, config, container) {
  var graphHook = (0, _react.useRef)();
  var data = config.data,
      nodeStyle = config.nodeStyle,
      nodeAnchorPoints = config.nodeAnchorPoints,
      nodeType = config.nodeType,
      edgeType = config.edgeType,
      edgeStyle = config.edgeStyle,
      width = config.width,
      height = config.height,
      layout = config.layout,
      minimapCfg = config.minimapCfg,
      behaviors = config.behaviors,
      nodeLabelCfg = config.nodeLabelCfg,
      edgeLabelCfg = config.edgeLabelCfg;
  var minimap;
  (0, _react.useEffect)(function () {
    if (graphInstance && !graphInstance.destroyed) {
      graphInstance.changeData(data);
      graphInstance.layout();
    }
  }, [data]);
  (0, _react.useEffect)(function () {
    if (graphInstance && !graphInstance.destroyed) {
      graphInstance.getNodes().forEach(function (node) {
        graphInstance.updateItem(node, {
          type: nodeType,
          style: nodeStyle,
          anchorPoints: nodeAnchorPoints,
          labelCfg: nodeLabelCfg
        });
      });
    }
  }, [nodeStyle, nodeAnchorPoints, nodeType]);
  (0, _react.useEffect)(function () {
    if (graphInstance && !graphInstance.destroyed) {
      graphInstance.getEdges().forEach(function (edge) {
        graphInstance.updateItem(edge, {
          type: edgeType,
          style: edgeStyle,
          labelCfg: edgeLabelCfg
        });
      });
    }
  }, [edgeStyle, edgeType]);
  (0, _react.useEffect)(function () {
    if (graphInstance && !graphInstance.destroyed) {
      var graphSize = (0, _util.getGraphSize)(width, height, container);
      graphInstance.changeSize(graphSize[0], graphSize[1]);
    }
  }, [container, width, height]);
  (0, _react.useEffect)(function () {
    if (graphInstance && !graphInstance.destroyed) {
      graphInstance.updateLayout(layout);
    }
  }, [layout]);
  (0, _react.useEffect)(function () {
    if (!minimapCfg || !graphInstance || graphInstance.destroyed) {
      return;
    }

    if (minimapCfg.show) {
      minimap = (0, _util.processMinimap)(minimapCfg, graphInstance);
      minimap && minimap.updateCanvas();
    } else {
      var _minimap = graphInstance.get('plugins')[0];
      _minimap && graphInstance.removePlugin(_minimap);
    }
  }, [minimapCfg]);
  (0, _react.useEffect)(function () {
    if (graphInstance && !graphInstance.destroyed) {
      var _graphInstance$get = graphInstance.get('modes'),
          defaultMode = _graphInstance$get.default;

      var removingBehaviors = [];
      defaultMode.forEach(function (be) {
        if ((0, _util2.isObject)(be)) {
          removingBehaviors.push(be.type);
        } else if ((0, _util2.isString)(be)) {
          removingBehaviors.push(be);
        }
      });
      graphInstance.removeBehaviors(removingBehaviors, 'default');
      graphInstance.addBehaviors(behaviors, 'default');
    }
  }, [behaviors]);
  (0, _react.useEffect)(function () {
    graphHook.current = graphInstance;

    if (graphInstance && !graphInstance.destroyed) {
      return function () {
        graphInstance.destroy();
        graphInstance = undefined;
      };
    }

    return;
  }, []);
  return {
    graphHook: graphHook
  };
}